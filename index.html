<html>
  <head>
    <title>Simple 3D Test</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: #000;
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 10px;
    				width: 100%;
    				text-align: center;
    			}
    </style>



		<script type="importmap">
			{
        
				"imports": {
					"three": "./build/three.module.js",
					"cannon-es": "./build/three/examples/jsm/physics/cannon-es.js",
					"cannon-es-debugger": "./build/three/examples/jsm/physics/cannon-es-debugger.js"
					
					
				}

			}
      
		</script>

		
	<script type="module"
    src="main.js"></script>
	
    </script>
	<script type="x-shader/x-vertex" id="vertexShadersdwSimple">
		void main()
		{
		  vec4 ViewPosition= modelViewMatrix * vec4(position,1.0);
		  gl_Position=projectionMatrix * ViewPosition;
		}
	  </script>
	<script type="x-shader/x-vertex" id="vertexShaderSimple">
		out vec2 uvInterpolator;
		varying vec3 vColor;

		void main() {
		  uvInterpolator = uv;
		  vec3 light = vec3( 0.5, 0.2, 1.0 );
		  light = normalize( light );
		  vec3 ViewNormal= normalize(normalMatrix * normal);
		  float dProd = dot( ViewNormal, light );
		  dProd=clamp(dProd,0.0,1.0);
		  vColor =  vec3( dProd );
		  vec4 ViewPosition= modelViewMatrix * vec4(position,1.0);
		  gl_Position=projectionMatrix * ViewPosition;
		
		}

		


	  </script>

	  <script type="x-shader/x-fragment" id="fragmentShaderSimple">
		in vec2 uvInterpolator;
		uniform float u_time;
		uniform sampler2D u_texture;
		uniform float u_movementY;
		uniform float u_movementX;
		uniform float u_Resolution;
		uniform float u_centre;
		uniform float u_dropShown;
		uniform float u_dropSize;
		uniform float u_lifeSpan;
		uniform int u_Intensity; 

		float randomGen1(float inputValue, float seed) {
			return fract(sin(inputValue *345.456) *seed);
		}

		float randomGen2(vec2 inputValue, float seed) {
			return fract(sin(dot(inputValue,vec2(123.456,43.12))) *seed);
		}
	
		vec2 rainDrops(vec2 uv, float seed) {
			float shiftY = randomGen1(0.5, seed);
			uv.y +=shiftY +u_time *u_movementY;


			float cellResolution = u_Resolution;
			uv *= cellResolution;

			float rowIndex = floor(uv.y);
			float shiftX = randomGen1(rowIndex, seed);
			uv.x += shiftX +u_time *u_movementX;
			
			vec2 cellIndex = floor(uv);
			vec2 cellUv = fract(uv);

			vec2 cellCentre = vec2(u_centre);
			float distanceFromCentre = distance(cellUv, cellCentre);
			float isInsideDrop = 1.0 - step(u_dropSize, distanceFromCentre);


			float dropIsShown = step(1.0-u_dropShown, randomGen2(cellIndex, seed +235.111));

			float rainIntensity = 1.0 - fract(u_time *0.1 +randomGen2(cellIndex, seed +36356.267) *2.0) *2.0;
			
			rainIntensity = clamp(sign(rainIntensity) *abs(rainIntensity * rainIntensity * rainIntensity * rainIntensity), 0.0, 1.0);
			

			vec2 vecToCentre = normalize(cellCentre - cellUv);
			vec2 dropValue = vecToCentre * distanceFromCentre *distanceFromCentre * 40.0;

			vec2 rainDrop = dropValue * dropIsShown *rainIntensity * isInsideDrop;

			return rainDrop;
		}
		void main()
		{
			vec2 uv = uvInterpolator;
			
			vec2 rainDrop = vec2(0.0);
			for(int i =0; i< u_Intensity; i++) {
				rainDrop += rainDrops(uv ,3999.21 + float(i) * 6969.420 +(u_time *u_lifeSpan));
			}
			uv+= rainDrop;
			
			vec4 color = texture2D(u_texture, uv*100.0);
			gl_FragColor = color;
		}
	  </script>
  </body>
</html>
